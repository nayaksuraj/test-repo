# ==============================================================================
# Default Values for Helm Chart
# ==============================================================================
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.
# Override these values using environment-specific values files
# ==============================================================================

# Replicas for the deployment
replicaCount: 2

# Image configuration
# REQUIRED: Set image.repository to your container registry and application name
# Example: docker.io/myorg/myapp or registry.company.com/team/application
image:
  repository: ""  # REQUIRED: Set via --set image.repository or values override
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion
  tag: ""

# Image pull secrets for private registries
imagePullSecrets: []
  # - name: registry-secret

# Override the chart name
nameOverride: ""
fullnameOverride: ""

# Service Account configuration
serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use
  name: ""

# Pod annotations
podAnnotations:
  prometheus.io/scrape: "true"
  prometheus.io/port: "8080"
  prometheus.io/path: "/actuator/prometheus"

# Pod security context
podSecurityContext:
  runAsNonRoot: true
  runAsUser: 1001
  fsGroup: 1001

# Container security context
securityContext:
  allowPrivilegeEscalation: false
  readOnlyRootFilesystem: false
  capabilities:
    drop:
      - ALL

# Service configuration
service:
  type: ClusterIP
  port: 80
  targetPort: 8080
  annotations: {}

# Ingress configuration
ingress:
  enabled: false
  className: "nginx"
  annotations:
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
  hosts:
    - host: app.example.com  # Update with your domain
      paths:
        - path: /
          pathType: Prefix
  tls:
    - secretName: app-tls  # Update with your TLS secret name
      hosts:
        - app.example.com  # Update with your domain

# Resource limits and requests
resources:
  limits:
    cpu: 1000m
    memory: 1Gi
  requests:
    cpu: 500m
    memory: 512Mi

# Horizontal Pod Autoscaler
autoscaling:
  enabled: false
  minReplicas: 2
  maxReplicas: 10
  targetCPUUtilizationPercentage: 80
  targetMemoryUtilizationPercentage: 80

# Liveness probe configuration
livenessProbe:
  httpGet:
    path: /actuator/health/liveness
    port: 8080
  initialDelaySeconds: 60
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3

# Readiness probe configuration
readinessProbe:
  httpGet:
    path: /actuator/health/readiness
    port: 8080
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3

# Startup probe configuration (for slow starting applications)
startupProbe:
  httpGet:
    path: /actuator/health/liveness
    port: 8080
  initialDelaySeconds: 0
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 30

# Node selector
nodeSelector: {}

# Tolerations
tolerations: []

# Affinity rules
affinity: {}

# Pod Disruption Budget
podDisruptionBudget:
  enabled: true
  minAvailable: 1

# Environment variables
env:
  - name: SPRING_PROFILES_ACTIVE
    value: "default"
  - name: JAVA_OPTS
    value: "-XX:+UseContainerSupport -XX:MaxRAMPercentage=75.0"

# Environment variables from ConfigMap
envFrom: []
  # - configMapRef:
  #     name: app-config

# Environment variables from Secrets
envFromSecret: []
  # - secretRef:
  #     name: app-secrets

# ConfigMap data
configMap:
  enabled: false
  data: {}
    # application.yaml: |
    #   server:
    #     port: 8080

# Secret data (base64 encoded values)
secret:
  enabled: false
  data: {}
    # DATABASE_PASSWORD: "cGFzc3dvcmQ="

# ServiceMonitor for Prometheus Operator
serviceMonitor:
  enabled: false
  interval: 30s
  path: /actuator/prometheus
  labels: {}

# Volume mounts
volumeMounts: []
  # - name: config
  #   mountPath: /config
  #   readOnly: true

# Volumes
volumes: []
  # - name: config
  #   configMap:
  #     name: app-config

# Extra labels to add to all resources
extraLabels: {}

# Rolling update strategy
strategy:
  type: RollingUpdate
  rollingUpdate:
    maxSurge: 1
    maxUnavailable: 0

# ==============================================================================
# Advanced Features (Optional)
# ==============================================================================

# Network Policy - Control pod-to-pod communication
networkPolicy:
  enabled: false
  policyTypes:
    - Ingress
    - Egress
  ingress: []
    # - from:
    #   - namespaceSelector:
    #       matchLabels:
    #         name: default
    #   ports:
    #   - protocol: TCP
    #     port: 8080
  egress: []
    # - to:
    #   - namespaceSelector: {}
    #   ports:
    #   - protocol: TCP
    #     port: 5432

# Init Containers - Run before main container starts
initContainers: []
  # - name: wait-for-db
  #   image: busybox:1.36
  #   command: ['sh', '-c', 'until nc -z postgres 5432; do echo waiting for db; sleep 2; done;']

# Sidecar Containers - Additional containers in the pod
sidecars: []
  # - name: log-shipper
  #   image: fluent/fluent-bit:2.0
  #   volumeMounts:
  #   - name: logs
  #     mountPath: /var/log

# Lifecycle Hooks - PreStop and PostStart hooks
lifecycle: {}
  # preStop:
  #   exec:
  #     command: ["/bin/sh", "-c", "sleep 15"]
  # postStart:
  #   exec:
  #     command: ["/bin/sh", "-c", "echo Hello from the postStart handler"]

# Topology Spread Constraints - Better pod distribution
topologySpreadConstraints: []
  # - maxSkew: 1
  #   topologyKey: topology.kubernetes.io/zone
  #   whenUnsatisfiable: DoNotSchedule
  #   labelSelector:
  #     matchLabels:
  #       app.kubernetes.io/name: app

# PodInfo - Inject pod metadata as environment variables
podInfo:
  enabled: false

# External Secrets - Integrate with external secret managers
externalSecret:
  enabled: false
  secretStore: ""  # Name of SecretStore or ClusterSecretStore
  secretStoreKind: SecretStore  # SecretStore or ClusterSecretStore
  refreshInterval: 1h
  data: []
    # - secretKey: DATABASE_PASSWORD
    #   remoteKey: /path/to/secret
    #   property: password  # Optional: specific property from secret
  dataFrom: []
    # - key: /path/to/secrets  # Import all keys from this path

# KEDA ScaledObject - Event-driven autoscaling
keda:
  enabled: false
  minReplicas: 1
  maxReplicas: 10
  pollingInterval: 30
  cooldownPeriod: 300
  triggers: []
    # - type: prometheus
    #   metadata:
    #     serverAddress: http://prometheus:9090
    #     metricName: http_requests_total
    #     threshold: '100'
    #     query: sum(rate(http_requests_total[2m]))
  fallback: {}
    # failureThreshold: 3
    # replicas: 6
  advanced: {}
    # horizontalPodAutoscalerConfig:
    #   behavior:
    #     scaleDown:
    #       stabilizationWindowSeconds: 300

# Certificate - Automated TLS certificate management
certificate:
  enabled: false
  secretName: ""  # Will default to <fullname>-tls if not specified
  issuerRef: letsencrypt-prod
  issuerKind: ClusterIssuer
  issuerGroup: ""
  commonName: ""
  dnsNames: []
    # - app.example.com
    # - www.app.example.com
  duration: ""  # e.g., 2160h (90 days)
  renewBefore: ""  # e.g., 360h (15 days)
  usages: []
    # - digital signature
    # - key encipherment

# Helm Tests - Validate deployment
tests:
  enabled: true
  image: busybox:1.36
  healthCheck:
    enabled: false
    path: /health

# PersistentVolumeClaim - Persistent storage
persistence:
  enabled: false
  accessModes:
    - ReadWriteOnce
  size: 8Gi
  storageClass: ""  # Use "-" for empty storageClassName
  annotations: {}
  selector: {}

# PrometheusRule - Custom alerting rules
prometheusRules:
  enabled: false
  interval: 30s
  labels: {}
  rules: []
    # - alert: HighErrorRate
    #   expr: rate(http_requests_total{status="500"}[5m]) > 0.05
    #   for: 10m
    #   labels:
    #     severity: critical
    #   annotations:
    #     summary: High error rate detected

# Vertical Pod Autoscaler - Automatic resource adjustment
vpa:
  enabled: false
  updateMode: Auto  # Off, Initial, Recreate, Auto
  resourcePolicy: {}
    # containerPolicies:
    # - containerName: app
    #   minAllowed:
    #     cpu: 100m
    #     memory: 128Mi
    #   maxAllowed:
    #     cpu: 2000m
    #     memory: 2Gi

# Istio Service Mesh - Traffic management
istio:
  enabled: false
  hosts: []
    # - app.example.com
  gateways: []
    # - istio-system/default-gateway
  http: []
    # - match:
    #   - uri:
    #       prefix: /api
    #   route:
    #   - destination:
    #       host: app
    #       port:
    #         number: 80
  trafficPolicy: {}
    # connectionPool:
    #   tcp:
    #     maxConnections: 100
    #   http:
    #     http1MaxPendingRequests: 50
    #     maxRequestsPerConnection: 2
    # outlierDetection:
    #   consecutiveErrors: 5
    #   interval: 30s
    #   baseEjectionTime: 30s
  subsets: []
    # - name: v1
    #   labels:
    #     version: v1
    # - name: v2
    #   labels:
    #     version: v2

# CronJob - Scheduled jobs
cronJob:
  enabled: false
  schedule: "0 0 * * *"  # Daily at midnight
  concurrencyPolicy: Forbid  # Allow, Forbid, Replace
  suspend: false
  failedJobsHistoryLimit: 1
  successfulJobsHistoryLimit: 3
  startingDeadlineSeconds: 200
  activeDeadlineSeconds: 600
  backoffLimit: 6
  restartPolicy: OnFailure
  command: []
    # - /bin/sh
    # - -c
    # - date; echo Hello from the Kubernetes cluster
  args: []
  resources: {}
  volumes: []
  volumeMounts: []
  podAnnotations: {}

# Headless Service - Direct pod access
headlessService:
  enabled: false
  annotations: {}
  publishNotReadyAddresses: false
